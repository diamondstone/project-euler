import pickle
from math import sqrt,factorial

     ################################
     ## Number theoretic functions ##
     ################################

def gcd(n,m): #returns the greatest common denominator of n and m, using Euclidean algorithm. Algorithm runs for one cycle less if n<m.
    if n*m==0: return n+m
    while n>0:
        p=m
        m=n
        n=p%m
    return m

def lcm(n,m): return n*m/gcd(n,m)

def eulerphi(n): # computes Euler's totient function through a prime factorization and inclusion/exclusion. Runs in roughly O(sqrt(n)) time, as opposed to the O(n) naive algorithm. Gives the wrong answer on 0 and 1 for the sake of speedup.
    factors=factorize(n)
    phi=n-1
    for i in range(1,len(factors)+1): #we iterate over products p of subsets of prime factors
        for j in itertools.combinations(factors,i):
            p=product(j)
            if i%2: phi-=(n-1)/p
            else: phi+=(n-1)/p
    return phi

def product(stuff): #returns the product of any iterable
    p = 1
    for i in stuff:
        p *= i
    return p

def totient_range(n,a,b): # computes the number of integers in [a,b] which are relatively prime to n. As in the algorithm for Euler's totient function, uses a prime factorization and inclusion/exclusion.
    if b<a: return 0
    factors=factorize(n)
    phi=b-a+1
    for i in xrange(1,len(factors)+1): #we iterate over products p of subsets of prime factors
        for j in itertools.combinations(factors,i):
            p=product(j)
            if i%2: phi-=b/p-(a-1)/p
            else: phi+=b/p-(a-1)/p
    return phi

def divisors(n): #returns a list of the proper divisors of an integer n>1
    divisors = [1]
    for i in xrange(2,int(sqrt(n))+1):
        if n%i==0: divisors.append(i)
    l=len(divisors)-1
    for i in xrange(l,0,-1):
        if divisors[i]**2 != n: divisors.append(n/divisors[i])
    return divisors

def isperfect(n):
    if sum(divisors(n))==n: return n
    return 0

def isfriendly(n):
    if isperfect(n): return 0
    if sum(divisors(sum(divisors(n))))==n: return n
    return 0

def isprime(n): #returns 1 if n is prime, 0 if n is composite
    if n<2:
        return None
    if n<4:
        return 1
    t=int(sqrt(n))
    for i in xrange(2,t+1):
        if n % i == 0: return 0
    return 1

def nextprime(n): #returns smallest prime strictly greater than n
    p=n+1
    if p % 2 == 0: p=p+1
    while isprime(p)==0:
        p=p+2
    return p

def sieve(n): #returns a list of all primes below n
    sievedata=[0]*2+[1]*(n-2)
    for i in xrange(1+int(sqrt(n))):
        if sievedata[i]==1:
            for j in xrange(2*i,n,i):
                sievedata[j]=0
    primes=[]
    for i in xrange(n):
        if sievedata[i]==1: primes.append(i)
    return primes

def factorize(n): #returns a list of the prime factors, with multiplicity.
    factors=[]
    p=2
    while n>1:
        if p>sqrt(n):
            factors.append(n)
            n=1
        elif n % p == 0:
            n=n/p
            factors.append(p)
        else:
            p+=1
    return factors

# collatz

def collatz(n): #computes the usual (nonreduced) collatz function of n
    if n % 2 == 0: return n/2
    return 3*n+1

def colchain(n): #computes the collatz trajectory until 1 is reached, then returns the trajectory as a list
    chain=[n]
    while n>1:
        n=collatz(n)
        chain.append(n)
    return chain

def int_sqrt(n): #returns the integer part of the square root of n; guaranteed to work on long ints.
    x = n
    while 1:
        y = (x + n/x)/2
        if y >= x:
            return x
        x = y
    
     ############################
     # Continued fraction tools #
     ############################

def cfrac_for_e(): #generator for terms in the continued fraction of e
    yield 2
    for n in itertools.count(2):
        if n%3: yield 1
        else: yield 2*n/3

def cfrac_for_sqrt(n): #generator for the continued fraction for sqrt(n)
#general mechanism: take (a*rt(n)+b)/c, subtract integer part to get (a*rt(n)+b')/c, invert to get c/(a*rt(n)+b'), rationalize, and simplify.
#requires int(sqrt(n)) to be the integer part of the square root of n; therefore, may fail if n is large enough that floating point arithmetic is inexact.
    if n==int(sqrt(n))**2:
        yield int(sqrt(n))
        while 1: yield 0
    a,b,c=1,0,1
    while 1:
        newterm=int((a*sqrt(n)+b)/c)
        yield newterm
        b-=c*newterm
        cc=a*a*n-b*b
        a*=c
        b*=(-1)*c
        c=cc
        d=gcd(a,(gcd(b,c)))
        a=a/d
        b=b/d
        c=c/d

def convergent(cfrac_gen,l): #returns the lth convergent to the continued fraction generated by cfrac_gen. cfrac_gen must be a generator object.
    terms=list(itertools.islice(cfrac_gen, l))
    d=terms.pop()
    n=1
    while terms:
        dd=d
        d=n+d*terms.pop()
        n=dd
    return (d,n)


     ###########################
     ## Some handy generators ##
     ###########################

def pair_gen(): #generates pairs (m,n) in order (0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),...
    for i in itertools.count(0):
        for j in xrange(i+1):
            yield (j,i-j)

def pair2_gen(): #generates pairs (m,n) with m>n>0 in order (2,1),(3,1),(3,2),(4,1),(4,2),...
    for i in itertools.count(2):
        for j in xrange(1,i):
            yield (i,j)

def pytriple_gen(): #generates primitive pythagorean triples
    for (m,n) in pair2_gen():
        if m%2==n%2: continue
        if gcd(m,n)!=1: continue
        yield (m**2-n**2,2*m*n,m**2+n**2)


     ###################
     ## Miscellaneous ##
     ###################

def removeduplicates(list1): #takes as input a sorted list, returns a new list consisting of the old list with repetitions removed
    if list1==[]: return []
    list2=[]
    old=list1[0]
    list2.append(old)
    for i in range(1,len(list1)):
        if list1(i)!=old:
            old=list1(i)
            list2.append(old)
    return list2

def numbertowords(n): # converts the integer n into the written english version. Currently only works for n<1000.
    digits=['','one','two','three','four','five','six','seven','eight','nine','ten','eleven','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen']
    tens=['','','twenty','thirty','forty','fifty','sixty','seventy','eighty','ninety']
    if n<20: return digits[n]
    if n<100:
        if n%10==0: return tens[n/10]
        else: return tens[n/10]+'-'+digits[n % 10]
    if n%100==0: return digits[n/100]+' hundred'
    else: return digits[n/100]+' hundred and '+numbertowords(n%100)

     #############################################
     ## Functions for dealing with permutations ##
     #############################################

def baseftonum(basef): #computes the number with "base" factorial representation basef (expressed as a vector of integers)
    num=0
    l=len(basef)
    for i in xrange(l): num+=factorial(l-i)*basef[i]
    return num
    

def numtobasef(num,l): # computes the l-"digit" "base" factorial representation of num (as a vector of integers)
    # there's probably a real name for this
    basef=[0]*l
    for i in xrange(l):
        basef[i]=num/factorial(l-i)
        num-=basef[i]*factorial(l-i)
    return basef

def baseftoperm(basef): # converts a base-factorial representation to the corresponding permutation (as a vector)
    basef.append(0)
    l=len(basef)
    perm=[0]*l
    for i in xrange(l):
        while perm[i] in perm[:i]: perm[i] += 1
        for j in xrange(basef[i]):
            perm[i]+=1
            while perm[i] in perm[:i]: perm[i] += 1
    return perm

def permtobasef(perm): # converts a base-factorial representation to the corresponding permutation 
    l=len(perm)-1
    basef=perm[:l]
    for i in xrange(l):
        for j in xrange(basef[i]):
            if j in perm[:i]: basef[i] -= 1
    return basef

def permtonum(perm): return baseftonum(permtobasef(perm))

def numtoperm(num,l): return baseftoperm(numtobasef(num,l-1))

def nextperm(perm):
    l=len(perm)
    num=permtonum(perm)+1
    if num==factorial(l): return None
    return numtoperm(num,l)

     ##########################################
     ## Functions for dealing with iterators ##
     ##########################################

def merge(iterator1,iterator2): #assuming iterator1 and iterator2 are in increasing order, iterates through their union in increasing order
   try:
      i1=iterator1.next()#want to yield neither
      i2=iterator2.next()#want to yield i1
      while True:
         if i1<i2:
            last=i1
            yield last
            i1=iterator1.next()#want to yield i2
         if i1>i2:
            last=i2
            yield last
            i2=iterator2.next()#want to yield i1
         if i1==i2:
            last=i1
            yield last
            i1=iterator1.next()#want to yield neither
            i2=iterator2.next()#want to yield i1
   except StopIteration:
      if i1>last: yield i1
      if i2>last: yield i2
      for i in iterator1: yield i
      for i in iterator2: yield i
