from math import sqrt
import itertools

def gcd(n,m): 
    if n*m==0: return n+m
    while n>0:
        p=m
        m=n
        n=p%m
    return m

def cfrac_for_e(): #generator for terms in the continued fraction of e
    yield 2
    for n in itertools.count(2):
        if n%3: yield 1
        else: yield 2*n/3

def cfrac_for_sqrt(n): #generator for the continued fraction for sqrt(n)
#general mechanism: take (a*rt(n)+b)/c, subtract integer part to get (a*rt(n)+b')/c, invert to get c/(a*rt(n)+b'), rationalize, and simplify.
#requires int(sqrt(n)) to be the integer part of the square root of n; therefore, may fail if n is large enough that floating point arithmetic is inexact.
    if n==int(sqrt(n))**2:
        yield int(sqrt(n))
        while 1: yield 0
    a,b,c=1,0,1
    while 1:
        newterm=int((a*sqrt(n)+b)/c)
        yield newterm
        b-=c*newterm
        cc=a*a*n-b*b
        a*=c
        b*=(-1)*c
        c=cc
        d=gcd(a,(gcd(b,c)))
        a=a/d
        b=b/d
        c=c/d

def convergent(cfrac_gen,l): #returns the lth convergent to the continued fraction generated by cfrac_gen. cfrac_gen must be a generator object.
    terms=list(itertools.islice(cfrac_gen, l))
    d=terms.pop()
    n=1
    while terms:
        dd=d
        d=n+d*terms.pop()
        n=dd
    return (d,n)

bestD=0
bestx=0
for s in range(1,32):
    for D in range(s**2+1,min((s+1)**2,1001)):
        x,y,l=0,0,0
        while x**2!=D*y**2+1:
            l+=1
            x,y=convergent(cfrac_for_sqrt(D),l)
        if x>bestx:
            bestx=x
            bestD=D
print bestD
